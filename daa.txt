Experiment 01
Code:
nterms = int(input("Enter number of terms: "))
# First two terms
n1, n2 = 0, 1
count = 0
# Check if the number of terms is valid
if nterms <= 0:
print("Please enter a positive integer")
elif nterms == 1:
print("Fibonacci sequence up to", nterms, ":")
print(n1)
else:
print("Fibonacci sequence:")
while count < nterms:
print(n1)
nth = n1 + n2
# Update values
n1, n2 = n2, nth
count += 1
Output:
PS D:\college BE\lab> python -u "d:\college BE\lab\DAA\exp01x.py"
Enter number of terms: 4
Fibonacci sequence:
0
1
1
2Experiment 02
Code:
# Define a class for the Huffman Tree Node
class Node:
def __init__(self, freq, symbol, left=None, right=None):
# Frequency of character
self.freq = freq
# Symbol (character)
self.symbol = symbol
# Left and right child nodes
self.left = left
self.right = right
# Huffman code (0 or 1)
self.huff = ''
# Function to print the nodes of the Huffman tree
def printNodes(node, val=''):
# Store the current huffman code value
newVal = val + str(node.huff)
# If node has left child, recursively call printNodes on left child
if node.left:
printNodes(node.left, newVal)
# If node has right child, recursively call printNodes on right child
if node.right:
printNodes(node.right, newVal)
# If the node is a leaf node, print the symbol and its corresponding Huffman code
if not node.left and not node.right:
print(f"{node.symbol} -> {newVal}")
# Characters for the Huffman tree
chars = ['a', 'b', 'c', 'd', 'e', 'f', 'g']
# Frequency of the characters
freq = [4, 7, 12, 14, 17, 43, 54]
# List containing unused nodes
nodes = []
# Converting characters and frequencies into Huffman tree nodes
for x in range(len(chars)):
nodes.append(Node(freq[x], chars[x]))
# Constructing the Huffman Tree
while len(nodes) > 1:# Sort all the nodes in ascending order based on their frequency
nodes = sorted(nodes, key=lambda x: x.freq)
# Pick the two nodes with the lowest frequency
left = nodes[0]
right = nodes[1]
# Assign Huffman code values to these nodes
left.huff = 0
right.huff = 1
# Create a new node by combining the two smallest nodes
newNode = Node(left.freq + right.freq, left.symbol + right.symbol, left, right)
# Remove the two smallest nodes and add the new node to the list of nodes
nodes.remove(left)
nodes.remove(right)
nodes.append(newNode)
# Huffman Tree is ready! Print the codes for each character
printNodes(nodes[0])
Output:
PS D:\college BE\lab> python -u "d:\college BE\lab\DAA\exp02.py"
a -> 0000
b -> 0001
c -> 001
d -> 010
e -> 011
f -> 10
g -> 11Experiment 03
Code:
def fractional_knapsack(value, weight, capacity):
# Calculate the value-to-weight ratio for each item
ratio = [v / w for v, w in zip(value, weight)]
# Create an index array and sort it based on the value-to-weight ratio in descending order
index = list(range(len(value)))
index.sort(key=lambda i: ratio[i], reverse=True)
max_value = 0 # To store the maximum value that can be carried
fractions = [0] * len(value) # To store the fraction of each item to take
for i in index:
# If the full item can be taken
if weight[i] <= capacity:
fractions[i] = 1 # Take the whole item
max_value += value[i]
capacity -= weight[i] # Reduce the remaining capacity
else:
# Take the fraction of the remaining capacity
fractions[i] = capacity / weight[i]
max_value += value[i] * (capacity / weight[i])
break # The knapsack is full now
return max_value, fractions
# Input number of items
n = int(input('Enter number of items: '))
# Input values of the items
value = input(f'Enter the values of the {n} item(s) in order: ').split()
value = [int(v) for v in value]
# Input weights of the items
weight = input(f'Enter the positive weights of the {n} item(s) in order: ').split()
weight = [int(w) for w in weight]
# Input the maximum capacity of the knapsack
capacity = int(input('Enter maximum weight: '))
# Calculate the maximum value and the fractions to take of each item
max_value, fractions = fractional_knapsack(value, weight, capacity)
# Output the result
print('The maximum value of items that can be carried:', max_value)print('The fractions in which the items should be taken:', fractions)
Output:
PS D:\college BE\lab> python -u "d:\college BE\lab\DAA\exp03.py"
Enter number of items: 3
Enter the values of the 3 item(s) in order: 24 15 25
Enter the positive weights of the 3 item(s) in order: 15 10 18
Enter maximum weight: 20
The maximum value of items that can be carried: 31.5
The fractions in which the items should be taken: [1, 0.5, 0]Experiment 04
Code:
class Item:
def __init__(self, value, weight):
self.value = value
self.weight = weight
self.ratio = value / weight
class Node:
def __init__(self, level, profit, weight, bound):
self.level = level
self.profit = profit
self.weight = weight
self.bound = bound
def bound(node, n, capacity, items):
if node.weight >= capacity:
return 0
profit_bound = node.profit
j = node.level + 1
total_weight = node.weight
while j < n and total_weight + items[j].weight <= capacity:
total_weight += items[j].weight
profit_bound += items[j].value
j += 1
if j < n:
profit_bound += (capacity - total_weight) * items[j].ratio
return profit_bound
def knapsack(items, capacity):
items = sorted(items, key=lambda item: item.ratio, reverse=True)
queue = []
root = Node(-1, 0, 0, 0)
root.bound = bound(root, len(items), capacity, items)
queue.append(root)
max_profit = 0
while queue:
node = queue.pop(0)
if node.level == -1:next_level = 0
else:
next_level = node.level + 1
if next_level < len(items):
left_child = Node(next_level, node.profit + items[next_level].value,
node.weight + items[next_level].weight, 0)
if left_child.weight <= capacity and left_child.profit > max_profit:
max_profit = left_child.profit
left_child.bound = bound(left_child, len(items), capacity, items)
if left_child.bound > max_profit:
queue.append(left_child)
right_child = Node(next_level, node.profit, node.weight, 0)
right_child.bound = bound(right_child, len(items), capacity, items)
if right_child.bound > max_profit:
queue.append(right_child)
return max_profit
# Input
n = int(input("Enter number of items: "))
values = [int(x) for x in input("Enter the values of the items: ").split()]
weights = [int(x) for x in input("Enter the weights of the items: ").split()]
capacity = int(input("Enter the capacity of the knapsack: "))
items = [Item(values[i], weights[i]) for i in range(n)]
# Solve 0/1 Knapsack using Branch and Bound
max_value = knapsack(items, capacity)
# Output
print("The maximum value that can be carried is:", max_value)
Output
PS D:\college BE\lab> python -u "d:\college BE\lab\DAA\exp04.py"
Enter number of items: 3
Enter the values of the items: 60 100 120
Enter the weights of the items: 10 20 30
Enter the capacity of the knapsack: 50
The maximum value that can be carried is: 220Experiment 05
Code:
#include <bits/stdc++.h>
#define N 4
using namespace std;
// Function to print the solution (N x N chessboard)
void printSolution(int board[N][N])
{
for (int i = 0; i < N; i++)
{
for (int j = 0; j < N; j++)
cout << board[i][j] << " ";
cout << endl;
}
}
// A utility function to check if a queen can be placed on board[row][col]
bool isSafe(int board[N][N], int row, int col)
{
int i, j;
// Check this row on the left side
for (i = 0; i < col; i++)
if (board[row][i])
return false;
// Check upper diagonal on the left side
for (i = row, j = col; i >= 0 && j >= 0; i--, j--)
if (board[i][j])
return false;
// Check lower diagonal on the left side
for (i = row, j = col; j >= 0 && i < N; i++, j--)
if (board[i][j])
return false;
return true;
}
// A recursive utility function to solve N Queen problem
bool solveNQUtil(int board[N][N], int col)
{
// Base case: If all queens are placed, return true
if (col >= N)
return true;// Consider this column and try placing this queen in all rows one by one
for (int i = 0; i < N; i++)
{
// Check if the queen can be placed on board[i][col]
if (isSafe(board, i, col))
{
// Place this queen in board[i][col]
board[i][col] = 1;
// Recur to place the rest of the queens
if (solveNQUtil(board, col + 1))
return true;
// If placing queen in board[i][col] doesn't lead to a solution, then remove queen
(backtrack)
board[i][col] = 0;
}
}
// If the queen cannot be placed in any row in this column, return false
return false;
}
// This function solves the N Queen problem using Backtracking. It mainly uses solveNQUtil
to solve the problem.
bool solveNQ()
{
int board[N][N] = {{0, 0, 0, 0},
{0, 0, 0, 0},
{0, 0, 0, 0},
{0, 0, 0, 0}};
if (solveNQUtil(board, 0) == false)
{
cout << "Solution does not exist";
return false;
}
printSolution(board);
return true;
}
// Driver code
int main()
{
solveNQ();
return 0;
}Output:
PS D:\college BE\lab> cd "d:\college BE\lab\DAA\" ; if ($?) { g++ exp05.cpp -o exp05 } ; if
($?) { .\exp05 }
0010
1000
0001
0100

